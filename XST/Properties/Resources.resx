<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ServerTips" xml:space="preserve">
    <value>[
    "Spigot#[插件服]Spigot 是 CraftBukkit 服务端之后的延续版本,比 CraftBukkit 优化了不少地方,支持 CraftBukkit 的插件,性能比 CraftBukkit 好很多,并且自带反作弊功能",
    "Akarin#[插件服]Akarin是一款支持多线程的 Minecraft 服务端,来自 “新维度”,前身是 TorchSpigot 服务端 注意:1 13 2版本仍未完善,还存在一些bug,在稳定前不建议用于生产环境",
    "Cauldron#[MOD+插件服]KCauldron/Cauldron 是一个可以装 Mod 的服务端,同时支持 Bukkit 插件",
    "CraftBukkit#[插件服]Craft Bukkit 是一个老牌的 Minecraft 服务端,支持大部分插件,功能比较完善,目前是更新比较快的几个服务端之一 这个服务端容易出现一些性能问题,如果你的服务器经常在日志中出现“Can't keep up”之类的报错,可以考虑使用 Spigot、PaperSpigot 等服务端 ",
    "Minecraft_Server#[纯净服]Minecraft Server是 Mojang 官方制作的原版服务端,更新非常快,基本上和 Minecraft 客户端版本同时发布,不能安装任何 Mod 和插件,只能够使用原版的命令和物品,适合基友服联机使用 ",
    "PaperSpigot#[插件服]Spigot 的进一步优化版本,在相关算法方面,较 Spigot 有所提高,优化 TPS 等,支持 CraftBukkit 和 Spigot 插件,API 没有太大修改 ",
    "SpongeForge#[MOD+插件服]SpongeForge 是一个全新的服务端,支持 Sponge 的专用插件,可装 Mod,兼容性比 Cauldron 相比提高了不少,适合开 MOD 服,支持的版本非常高,是目前支持 MOD 的服务端里兼容版本最高的服务端 ",
    "SpongeVanilla#[插件服]SpongeVanilla 是 SpongeForge 的纯净版本,同样支持 SpongeForge 的插件 性能相对较好,占用的内存较少,适合低配机器开服,对 Bukkit 插件的支持不佳,插件非常少,配置不方便,不能安装Mod ",
    "CubeRite#[插件服]CubeRite 是一个基于 C++ 编写的开源高性能 Minecraft 服务端 目前 Cuberite 已经可以做到大部分的基于 Bukkit 架构的 Minecraft 服务端（例如 Spigot）的功能,并且在性能方面具有更大的优势 ",
    "TacoSpigot#[插件服]TacoSpigot 是 Spigot 的优化版本,支持 CraftBukkit 和 Spigot 的插件,API 基本无变化,自带反作弊 ",
    "TorchSpigot#[插件服]TorchSpigot是一款由国人制作的服务端,是 Spigot 的优化版本,支持非常多插件,性能强悍,支持多核心 CPU 运算,自带反作弊功能 ",
    "CatServer#[MOD+插件服]CatServer是一款MOD+插件兼容性较好的一款服务端,但是非常吃内存、CPU只用MOD的话还是建议用SpongeForge",
    "Nukkit#Nukkit 是一款由 Java 驱动的 Minecraft PE 携带版服务端,适合开一个多人联机的 PE 版本服务器 ",
    "NukkitX#NukkitX 应该是 Nukkit 的强化 / 后续版本,这是一个高性能的 Minecraft PE 基岩版服务器,由 Java 强力驱动 ",
    "Bedrock_Server#Bedrock 是 Minecraft PE 基岩版,也叫携带版或手机版,Bedrock Server 是 Mojang 官方提供的服务端 Bedrock Server 不能安装插件,只能用于纯净游戏联机使用 "
]</value>
  </data>
  <data name="String1" xml:space="preserve">
    <value>{
  "Files": {
    "WorkingPath": "",
    "JavaPath": "",
    "UseDefaultDirectory": "false",
    "DownloadForm": "XINGAPI",
    "DownloadFilesPath":"","jar":"server.jar"
  },
  "JVM": {
    "Memory": "1024"
  }
}</value>
  </data>
</root>